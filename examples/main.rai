# simple call to `println`
(println "Raiton!")

# examples of string quoting
"'single quotes work here'"
'"double quotes work here"'
"double quote escape check \""
'single quote escape check \''

# lambda passed to the `map` function
(map [1 2 3] \x: (square x))

# explicit type declaration in angle brackets
<string>
env: "development"

# array type definition with mandatory size
<[3: number]>
my_array: [3: 1 2 3]

# slice type definition with no size specified
<[number]>
my_slice: [1 2 3] # slice from array

# a function type declaration denoted with arrow `->`
<number -> number -> number>
add_numbers a b: (add a b)

# type definition acting as aliasing
type name: string

# type definition of a `person` record
type person: {
  name: string
}

# this is a scope, like the file level scope
main {
  # just a definition, like at the file level scope
  greeting: "Hello, Raiton!"

  # just a type definition, like at the file level scope
  type penguin: {
    name: string
    fave_fish: string
  }

  # definition with explicit type declaration
  <penguin>
  peng: { name: "Peng" fave_fish: "sardines" }

  # these expressions get evaluated in order
  # when `main` is evaluated
  (println 123.4)
  (println greeting)
  (println (greeting)) # also valid as above

  # these are all valid expressions, tho pointless here
  { name: "Peng" fave_fish: "sardines" }
  [1 2 3]
  "This is legal"

  # because a definition starts with an identifier, due to ambiguity,
  # parentheses are needed around the identifier
  # the last expression is what the entire scope evaluates to
  (greeting)
}

# this is a classic sum type with the option to pass
# arguments to the constructors
type color: | Red | Green | Blue | RGB: { r:uint g:uint b:uint }

<color>
red: color.Red # the single instance of color.Red

<color>
green: (color.Green) # if evaluated, evaluates to the single instance of color.Green

blue: (color.Blue) # inferred type color

white: (color.RGB { r: 0 g: 0 b: 0}) # evaluated to color.RGB but with arguments

