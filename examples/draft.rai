# NOTE: This file is just used for drafting and ideas

<string -> string>
greeter name {
    message: (concat "Hello, " name)

    message
}

# NOTE: All functions only have one argument! Partial function application is a thing...

# definitions like these are still lazy evaluated, meaning they're evaluated
# only when referenced
<string>
name: "Tojuro"

<std.net.url -> string result>
download_json url {
    use std.net.http

    # this is a request value, but it's lazily evaluated only when referenced
    # below in the `http.body` function call
    request: (http.get url)

    (http.body.json request)
}

<std.net.url list -> list of result of string>
download_a_lot_of_json urls {
    use std.sync.wait_all

    work: (map urls \url: \:(download_json url))

    # `wait_all` takes a list of unit -> 'a functions and starts
    # a coroutine for each of them and then waits for all of them
    # to finish
    # `work` is a function declared above; gets implicitly called
    # and returns a list of unit -> 'a functions
    # `wait_all` returns 'a list of results of each of the threads

    # |(unit -> 'a) list|
    (wait_all work)
}

# main is the entry point to the program?
main {
    use std.{io.{println endl} string.join}

    all_json: (download_a_lot_of_json ["http://json.com/1", "http://json.com/2"])

    (println (greeter "Tojuro"))
    (println "Before")
    (println (join all_json endl))
    (println "After json downloaded")
}

# Guards can be used to define multiple function implementations
factorial n
| (equ n 0) : 1
| otherwise : (mul n (factorial (dec n)))

# Pattern matching like this is also possible:
factorial 0: 1
factorial n: (mul n (factorial (dec n)))

# this is an enum/sum type; variants can have constructors of other data
type my_option: Some 'a | None

# this is a record/struct
type person: {
    name: string
    age: int8
}

# this is a scoped function definition to the person type
<person -> bool>
person.is_of_age self: (gt self.age 18)

# similar to
<person -> bool>
is_of_age p: (gt p.age 18)

# now it's possible to
somefn: {
    <person> jeff: { name: "Jeff", age: 24 }

    (jeff.is_of_age)
}

# the constructor can have a record as data
type color: Red | Green | Blue | RGB { r: uint8, g: uint8, b: uint8 }

