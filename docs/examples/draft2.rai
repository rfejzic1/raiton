# TODO: Stay as close to C as possible!
#       Figure out how to do memory allocations on stack or virtual stack for closures...
#
#       For example, each closure can be allocated as an object of bindings for that clojure.
#       Then, instead of allocating that on the heap, can I pre-allocate memory on a stack
#       and reserve it for calls to such a closure? Can I resolve this by traversing the AST
#       to figure this out?
#       What if there are too many closures and these objects wouldn't fit on the stack?
#       Could I just pre-allocate a single block of memory on the heap to act as a virtual stack
#       and use the real stack for smaller objects?
#       By doing so, I could still have the speed of accessing existing memory without having to
#       allocate/reallocate and would just compute the exact size of the pre-allocated memory
#       during compile time.
#       What if I return closures of different sizes/structures/bindings? How would I compute what
#       the size of such objects is during compile time?

# top of the file is the module declaration
module main

# next at the top level are the `use` statements to include other modules
use std.fmt

# after this, order independent bindings
# ident `:` expr

awesome : "Raiton"

# bindings and expressions can be annotated with `@`

# `struct` is a function that takes a binding AST node as argument and registers a new struct type
# in the type system with the binding name; it also creates helper associated functions, like .eq .to_str etc.

# this works because `@` is a compile time evaluation annotation, which passes the compiler context and the node
# to which it is applied to the annotation expression;
# like in the example above, `struct` would be a built-in function that get's partially applied already (the compiler context is bound first)
# and then it's applied the node and then other parameters if it needs them (in this case no);
# func structFunc(ctx compiler.Context, node ast.Node) (ast.Node, error) { ... }

# you can also define your own compiler functions:
# @compiler
# my_func : fn ctx node other_param { ... }
#
# and would use it as:
# @(my_func "other param value")
# { :some :ast :node :goes :here }

@struct 
person : {
  :name string
  :age number
}

# this is how to do receiver functions/methods/bindings (functions that can be accessed on a type via a selector `.`)
# it will help with the LSP experience:
# TODO: Figure out what does the `.` (selector) operator do?
person.info : fn self: `$(self.name)`

person.eq : fn self other: (eq self.name other.name)

# the selector is used to select an associated object to the object applied to; for example:
# - on a struct a selector selects the field; (:name person) person.name
# - on a map whose key is a keyword it accesses the member; (:key1 mymap) mymap.key1
# - can be used in a binding to associate object to existing objects; person.eq : fn ... but the left operand has to be defined
# - on an array can be used to access the element; (0 my_array) my_array.0

tojuro : @person {
  :name "Tojuro"
  :age 25
}

# what @person does:
tojuro_2 : (person.new { :name "Tojuro" :age 25 })

tojuro_info : (person.info tojuro)

person.to_string : fn self: `$(self.name) is $(self.age) years old.`

sum_them : fn a b: (add a b)

# main is the entry point to the program; module main, function main (main.main)
main : fn args {
  (fmt.println (greet "World"))
}

greet : fn name {
  @enum
  choices : { :yes :no }

  my_choice : @choices :yes # reference the `choice` enum variant by the given keyword
  my_other_choice : choices.yes # use the bindings generated by @enum on the choice type
  # same as `my_other_choice : :yes` having associated the type in AST to be `choice`

  choices.to_string : fn self:
    match self {
      :yes : "Yes"
      :no : "No"
    }

  greeting : "Hello, "

  (concat greeting name)
}

fib : fn n {
  if (lte n 2): 1
  else: (add (fib * sub n 1) (fib * sub n 1))
}

fn fib n {
  if (lte n 2):
    1
  else:
    (add (fib * sub n 1) (fib * sub n 1))
}

fib : fn n {
  if (lte n 2): 1
  else {
    prev: (fib (sub n 1))
    second_prev: (fib (sub n 2))

    (add prev second_prev)
  }
}

print_ten : fn str {
  # optional parameters to functions? find an alternative more functional way to compose, instead of optional
  # function parameters!!!
  for n in (range.to 10): (println str)
  for n in (range.descend 10): (println str)
}

process_input : fn {
  lines : ((std.io.lines_n 10).collect)

  for line in lines: (printf "You entered: %s\n" line)
}

# annotations should be handled after the inital AST is formed and then transform the inital AST
# into another AST representation; also annotations could log at compile time and also emit errors
# in case the annotation fails
@if (eq compiler.os :linux):
  (parse `(fmt.println "linux")`)
else:
  (parse `(fmt.println "not linux")`)


# Rob Pike:
# strong std lib (plan to do)
# concurrency (I would like it to be "bring your own runtime" and provide primitives via std)
# composition over inheritance (no inheritance; using structs)
# dependency management (plan to do a tool similar to go)
# fast builds (I'm thinking about rewriting this in C)
# testing and tooling (plan to do a tool similar to go)
# formatting (something like go fmt is the goal)
# backwards compatibility (I don't know how I would do this, but I hope it's doable)
# readability over cleverness (this is the hardest part, I'm hoping to have a simple language like C but more functional)

